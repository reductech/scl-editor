@using JetBrains.Annotations
@using System.IO
@using System.IO.Abstractions
@using System.IO.Abstractions.TestingHelpers
@using System.Threading
@using BlazorDownloadFile


<InputFile id='fileInput112' OnChange="OnInputFileChanged" hidden multiple/>

<MudButton HtmlTag="label"
           Variant="Variant.Filled"
           Color="Color.Primary"
           StartIcon="@Icons.Filled.CloudUpload"
           for="fileInput112">
  Upload File
</MudButton>


<MudTable Items="GetFileData()" Hover="true" Breakpoint="Breakpoint.Sm">
  <HeaderContent>
    <MudTh>Path</MudTh>
    <MudTh>Text</MudTh>
    <MudTh>LastModified</MudTh>
    <MudTh>Size</MudTh>
    <MudTh>Open</MudTh>
    <MudTh>Download</MudTh>
    <MudTh>Remove</MudTh>
  </HeaderContent>
  <RowTemplate>
    <MudTd DataLabel="Path">@context.Path</MudTd>
    <MudTd DataLabel="Text">@context.TruncatedText</MudTd>
    <MudTd DataLabel="LastModified">@context.LastWriteTime</MudTd>
    <MudTd DataLabel="Size">@context.ByteCount</MudTd>
    <MudTd DataLabel="Open">
      <MudIconButton Icon='@Icons.Material.Filled.OpenInBrowser' OnClick='() => SetSCL(context.Path)'/>
    </MudTd>
    <MudTd DataLabel="Download">
      <MudIconButton Icon='@Icons.Material.Filled.FileDownload' OnClick='() => Download(context.Path)'/>
    </MudTd>
    <MudTd DataLabel="Remove">
      <MudIconButton Icon='@Icons.Material.Filled.Delete' OnClick='() => DeleteFile(context.Path)'/>
    </MudTd>
  </RowTemplate>
</MudTable>

<MudGrid Justify="Justify.Center" Spacing="4">
  <MudItem>
    <MudButton OnClick="@ClearFiles" Disabled="@(!FilesExist())" Color="Color.Error" Variant="Variant.Filled">Clear</MudButton>
  </MudItem>
</MudGrid>

@code {
  string _dragEnterStyle;

  [Parameter]
  public MockFileSystem FileSystem { get; set; }

  [Parameter]
  public Func<string, Task> SetSCLAction { get; set; }

  [Inject]
  IBlazorDownloadFileService BlazorDownloadFileService { get; set; }

  async Task Download(string fileName)
  {
    var text = FileSystem.GetFile(fileName).TextContents;
  //var file = Files[fileName];
    await BlazorDownloadFileService.DownloadFileFromText(fileName, text, "text/plain");
  }

  async Task SetSCL(string fileName)
  {
    var text = FileSystem.GetFile(fileName).TextContents;
    await SetSCLAction(text);
  }

  public static string Truncate(string value, int maxLength)
  {
    if (string.IsNullOrEmpty(value))
      return value;

    if (value.Length <= maxLength)
      return value;
    else
      return value.Substring(0, maxLength) + "...";
  }

  async Task OnInputFileChanged(InputFileChangeEventArgs e)
  {
    var files = e.GetMultipleFiles();

    foreach (var browserFile in files)
    {
      using var reader = new StreamReader(browserFile.OpenReadStream());

      var text = await reader.ReadToEndAsync();
      var mfd = new MockFileData(text);

      FileSystem.AddFile(browserFile.Name,mfd);
    }
  }

  bool FilesExist()
  {
    return FileSystem.AllFiles.Any();
  }

  void DeleteFile(string path)
  {
    FileSystem.RemoveFile(path);
  }

  void ClearFiles()
  {
    foreach (var file in FileSystem.AllFiles.ToList())
    {
        FileSystem.RemoveFile(file);
    }
  }

  IEnumerable<FileData> GetFileData()
  {

    foreach (var file in FileSystem.AllFiles)
    {
      var mfd =  FileSystem.GetFile(file);

      var byteCount = System.Text.Encoding.Unicode.GetByteCount(mfd.TextContents);

      var truncatedText = Truncate(mfd.TextContents, 100);
      yield return new FileData(file, mfd.LastWriteTime, truncatedText, byteCount);
    }
  }

  record FileData(string Path, DateTimeOffset LastWriteTime, string TruncatedText, int ByteCount);

}

